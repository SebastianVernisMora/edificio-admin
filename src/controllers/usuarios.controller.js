import bcrypt from 'bcryptjs';\nimport { handleControllerError } from '../utils/errorHandler.js';\nimport { \n  logUserCreation, \n  logUserUpdate, \n  logUserDeletion, \n  logPermissionChange, \n  logRoleChange \n} from '../utils/auditLog.js';\n\n// GET /api/usuarios - Obtener todos los usuarios\nexport const obtenerUsuarios = async (req, res) => {\n  try {\n    const { readData } = await import('../data.js');\n    const data = readData();\n    \n    const usuarios = data.usuarios.map(u => ({\n      ...u,\n      password: undefined // No enviar password en respuestas\n    }));\n    \n    res.json({ ok: true, usuarios });\n  } catch (error) {\n    return handleControllerError(error, res, 'obtenerUsuarios');\n  }\n};\n\n// POST /api/usuarios - Crear nuevo usuario\nexport const crearUsuario = async (req, res) => {\n  try {\n    const { readData, writeData } = await import('../data.js');\n    const data = readData();\n    const { nombre, email, rol, departamento, telefono, password } = req.body;\n\n    // Validaciones\n    if (!nombre || !email || !rol || !departamento || !password) {\n      return res.status(400).json({ \n        ok: false, \n        msg: 'Faltan campos obligatorios: nombre, email, rol, departamento, password' \n      });\n    }\n\n    // Validar roles permitidos\n    const rolesPermitidos = ['ADMIN', 'INQUILINO', 'COMITE'];\n    if (!rolesPermitidos.includes(rol)) {\n      return res.status(400).json({ \n        ok: false, \n        msg: 'Rol no válido. Roles permitidos: ADMIN, INQUILINO, COMITE' \n      });\n    }\n\n    // Validar email único\n    if (data.usuarios.find(u => u.email === email)) {\n      return res.status(400).json({ ok: false, msg: 'El email ya está en uso' });\n    }\n\n    // Validar departamento único para inquilinos\n    if (rol === 'INQUILINO' && data.usuarios.find(u => u.departamento === departamento && u.rol === 'INQUILINO')) {\n      return res.status(400).json({ ok: false, msg: 'El departamento ya está asignado' });\n    }\n\n    // Validar formato de departamento para inquilinos\n    if (rol === 'INQUILINO') {\n      const deptoRegex = /^[1-5]0[1-4]$/;\n      if (!deptoRegex.test(departamento)) {\n        return res.status(400).json({ \n          ok: false, \n          msg: 'Departamento inválido. Formato esperado: 101-504 (piso + depto)' \n        });\n      }\n    }\n\n    // Hash de la contraseña\n    const passwordHash = await bcrypt.hash(password, 10);\n    \n    // Generar ID único\n    const newId = data.usuarios.length > 0 \n      ? Math.max(...data.usuarios.map(u => u.id)) + 1 \n      : 1;\n    \n    const nuevoUsuario = {\n      id: newId,\n      nombre,\n      email,\n      password: passwordHash,\n      rol,\n      departamento,\n      telefono: telefono || null,\n      legitimidad_entregada: false,\n      estatus_validacion: 'pendiente',\n      fechaCreacion: new Date().toISOString(),\n      activo: true\n    };\n\n    data.usuarios.push(nuevoUsuario);\n    writeData(data);\n\n    // Log de auditoría para creación de usuario\n    const actor = req.usuario;\n    const ip = req.ip || req.connection.remoteAddress;\n    const userAgent = req.get('User-Agent');\n    \n    logUserCreation(nuevoUsuario, actor, ip, userAgent);\n\n    const respuesta = { ...nuevoUsuario, password: undefined };\n    res.status(201).json({ ok: true, usuario: respuesta });\n  } catch (error) {\n    return handleControllerError(error, res, 'crearUsuario');\n  }\n};\n\n// PUT /api/usuarios/:id - Actualizar usuario\nexport const actualizarUsuario = async (req, res) => {\n  try {\n    const { readData, writeData } = await import('../data.js');\n    const data = readData();\n    const id = parseInt(req.params.id);\n    const usuario = data.usuarios.find(u => u.id === id);\n\n    if (!usuario) {\n      return res.status(404).json({ ok: false, msg: 'Usuario no encontrado' });\n    }\n\n    // Guardar datos anteriores para auditoría\n    const usuarioAnterior = { ...usuario };\n    \n    const { nombre, email, rol, departamento, telefono, estatus_validacion, password } = req.body;\n\n    // Validar email único (excluyendo el usuario actual)\n    if (email && data.usuarios.find(u => u.email === email && u.id !== id)) {\n      return res.status(400).json({ ok: false, msg: 'El email ya está en uso' });\n    }\n\n    // Validar departamento único para inquilinos (excluyendo el usuario actual)\n    if (rol === 'INQUILINO' && departamento && \n        data.usuarios.find(u => u.departamento === departamento && u.rol === 'INQUILINO' && u.id !== id)) {\n      return res.status(400).json({ ok: false, msg: 'El departamento ya está asignado' });\n    }\n\n    // Actualizar campos\n    if (nombre !== undefined) usuario.nombre = nombre;\n    if (email !== undefined) usuario.email = email;\n    if (rol !== undefined) usuario.rol = rol;\n    if (departamento !== undefined) usuario.departamento = departamento;\n    if (telefono !== undefined) usuario.telefono = telefono;\n    if (estatus_validacion !== undefined) usuario.estatus_validacion = estatus_validacion;\n    if (password) {\n      usuario.password = await bcrypt.hash(password, 10);\n    }\n\n    writeData(data);\n\n    // Log de auditoría\n    const actor = req.usuario;\n    const ip = req.ip || req.connection.remoteAddress;\n    const userAgent = req.get('User-Agent');\n    \n    // Log general de actualización\n    logUserUpdate(id, usuarioAnterior, usuario, actor, ip, userAgent);\n    \n    // Log específico para cambio de rol\n    if (usuarioAnterior.rol !== rol && rol !== undefined) {\n      logRoleChange(id, usuarioAnterior.rol, rol, actor, ip, userAgent);\n    }\n\n    const respuesta = { ...usuario, password: undefined };\n    res.json({ ok: true, usuario: respuesta });\n  } catch (error) {\n    return handleControllerError(error, res, 'actualizarUsuario');\n  }\n};\n\n// DELETE /api/usuarios/:id - Eliminar usuario\nexport const eliminarUsuario = async (req, res) => {\n  try {\n    const { readData, writeData } = await import('../data.js');\n    const data = readData();\n    const id = parseInt(req.params.id);\n    \n    // No permitir eliminar el admin principal\n    if (id === 1) {\n      return res.status(400).json({ ok: false, msg: 'No se puede eliminar el administrador principal' });\n    }\n\n    const index = data.usuarios.findIndex(u => u.id === id);\n    if (index === -1) {\n      return res.status(404).json({ ok: false, msg: 'Usuario no encontrado' });\n    }\n\n    // Guardar datos del usuario antes de eliminarlo para auditoría\n    const usuarioAEliminar = { ...data.usuarios[index] };\n\n    data.usuarios.splice(index, 1);\n    writeData(data);\n\n    // Log de auditoría para eliminación\n    const actor = req.usuario;\n    const ip = req.ip || req.connection.remoteAddress;\n    const userAgent = req.get('User-Agent');\n    \n    logUserDeletion(usuarioAEliminar, actor, ip, userAgent);\n\n    res.json({ ok: true, msg: 'Usuario eliminado exitosamente' });\n  } catch (error) {\n    return handleControllerError(error, res, 'eliminarUsuario');\n  }\n};\n\n// PUT /api/usuarios/:id/editor-role - Actualizar rol de editor\nexport const actualizarRolEditor = async (req, res) => {\n  try {\n    // Check if user is admin or superadmin\n    if (req.usuario.rol !== 'ADMIN' && req.usuario.rol !== 'SUPERADMIN') {\n      return res.status(403).json({\n        ok: false,\n        msg: 'Acceso denegado'\n      });\n    }\n    \n    const { id } = req.params;\n    const { rol_editor, permisos_editor } = req.body;\n    \n    const { readData, writeData } = await import('../data.js');\n    const data = readData();\n    const usuarioIndex = data.usuarios.findIndex(u => u.id === parseInt(id));\n    \n    if (usuarioIndex === -1) {\n      return res.status(404).json({\n        ok: false,\n        msg: 'Usuario no encontrado'\n      });\n    }\n    \n    const usuario = data.usuarios[usuarioIndex];\n    \n    // Only inquilinos can have editor roles\n    if (usuario.rol !== 'INQUILINO') {\n      return res.status(400).json({\n        ok: false,\n        msg: 'Solo los inquilinos pueden tener roles de editor'\n      });\n    }\n    \n    // Validate editor role\n    const validEditorRoles = ['cuotas', 'presupuestos', 'gastos', 'anuncios', 'solicitudes'];\n    if (rol_editor && !validEditorRoles.includes(rol_editor)) {\n      return res.status(400).json({\n        ok: false,\n        msg: 'Rol de editor inválido'\n      });\n    }\n    \n    // Update user\n    data.usuarios[usuarioIndex].rol_editor = rol_editor;\n    data.usuarios[usuarioIndex].permisos_editor = permisos_editor || {\n      lectura: true,\n      escritura: false,\n      aprobacion: false\n    };\n    \n    writeData(data);\n    \n    // Return updated user without password\n    const { password, ...usuarioActualizado } = data.usuarios[usuarioIndex];\n    \n    res.json({\n      ok: true,\n      usuario: usuarioActualizado,\n      msg: 'Rol de editor actualizado correctamente'\n    });\n    \n  } catch (error) {\n    return handleControllerError(error, res, 'actualizarRolEditor');\n  }\n};\n