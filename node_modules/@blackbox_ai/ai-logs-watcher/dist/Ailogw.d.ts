import { type ModelSettings } from "@openai/agents";
import z from "zod";
import { AilogwVoiceProvider } from "./voice";
import { type ClientOptions } from "openai";
export declare const LogDiagnosticSchema: z.ZodObject<{
    status: z.ZodEnum<["critical", "warning", "normal"]>;
    topErrors: z.ZodNullable<z.ZodOptional<z.ZodArray<z.ZodString, "many">>>;
}, "strip", z.ZodTypeAny, {
    status: "critical" | "warning" | "normal";
    topErrors?: string[] | null | undefined;
}, {
    status: "critical" | "warning" | "normal";
    topErrors?: string[] | null | undefined;
}>;
export type LogDiagnostic = z.infer<typeof LogDiagnosticSchema>;
export declare namespace AilogwTypes {
    type logStatus = "normal" | "warning" | "critical";
    type maybePromise<T> = Promise<T> | T;
    type maybeArray<T> = T | T[];
    type logType = string;
    type alertSendSms = (numberFrom: string, customContent?: string) => Promise<boolean>;
    /**
     * Diagnostic information provided to alert event callbacks.
     * Contains both the raw AI analysis results and a formatted string representation.
     */
    type alertDiagnostic = {
        /** Raw diagnostic data from the AI analysis, including status and error line markers */
        raw: LogDiagnostic;
        /** Human-readable formatted string containing the diagnostic information and error details */
        formatted: string;
    };
    /**
     * Parameters passed to the alert event callback function.
     */
    type alertEventParams = {
        /** Current Ailogw configuration options */
        options: AilogwTypes.options;
        /** All collected logs */
        logs: logType[];
        /** AI analysis results with formatted output */
        diagnostic: Readonly<alertDiagnostic>;
        /** Function to send SMS notifications */
        sendSms: alertSendSms;
        voice: AilogwVoiceProvider | undefined;
    };
    type CreateLoggerOptions = {
        destination?: {
            log?: string;
            error?: string;
            warn?: string;
            info?: string;
            debug?: string;
        };
    };
    /**
     * Configuration for timestamp-based log filtering
     */
    type TimestampConfig = {
        /**
         * Regular expression to extract timestamp from log line
         * Should have a capturing group for the timestamp
         * @example /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)/ for ISO format
         * @example /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/ for "YYYY-MM-DD HH:mm:ss"
         */
        regex: RegExp;
        /**
         * Format string or parser function to convert extracted timestamp to Date
         * If string, should be compatible with Date constructor
         * If function, receives the matched timestamp string and returns a Date
         * @example "iso" for ISO 8601 format (default)
         * @example (ts) => new Date(ts.replace(' ', 'T'))
         */
        parser?: "iso" | ((timestamp: string) => Date);
    };
    /**
     * Options for triggerAnalysis method
     */
    type TriggerAnalysisOptions = {
        /** Whether to clear all logs after analysis */
        flush?: boolean;
        /** Number of recent logs to analyze (ignored if timeRange is provided) */
        tailAmount?: number;
        /** Time range filter for logs */
        timeRange?: {
            /** Start time (inclusive) */
            from: Date;
            /** End time (inclusive) */
            to: Date;
            /** Timestamp configuration for parsing log timestamps */
            timestampConfig: TimestampConfig;
        };
    };
    type alertEventCallback = (params: alertEventParams) => maybePromise<void>;
    type VoiceProvider = {
        provider: "elevenLabs";
        credentials: {
            apiKey: string;
        };
    };
    /**
     * Configuration options for creating an Ailogw instance.
     */
    type options = {
        /**
         * Twilio configuration for SMS notifications.
         * Can be provided via options or environment variables.
         *
         * @example
         * ```typescript
         * twilio: {
         *   accountSid: "ACxxxx",      // Or set AILOGW_TWILIO_ACCOUNT_SID env var
         *   authToken: "your-token",   // Or set AILOGW_TWILIO_AUTH_TOKEN env var
         *   numberFrom: "+17153645914" // Or set AILOGW_TWILIO_NUMBER_FROM env var
         * }
         * ```
         */
        twilio?: {
            /** Twilio Account SID */
            accountSid?: string;
            /** Twilio Auth Token */
            authToken?: string;
            /** Phone number purchased from Twilio (used as "from" number) */
            numberFrom?: string;
        };
        voice?: VoiceProvider | AilogwVoiceProvider;
        /**
         * Unique identifier for this log watcher instance.
         * Used in alert messages and internal logging.
         *
         * @example "vercel", "production-api", "database-logs"
         */
        name: string;
        /**
         * Whether to automatically start polling when instance is created.
         * @default true
         */
        activate?: boolean;
        /**
         * Whether to enable console logging for this instance.
         * @default false
         */
        log?: boolean;
        /**
         * Configuration for the AI client (OpenAI Agents).
         * @example
         * ```typescript
         * clientOptions: {
         *   apiKey: "sk-xxx"
         * }
         * ```
         */
        clientOptions?: ClientOptions;
        /**
         * AI model settings for log analysis. 100% OpenAI compatible
         * @example
         * ```typescript
         * modelSettings: {
         *   model: "gpt-4",
         *   temperature: 0.1
         * }
         * ```
         */
        modelSettings?: ModelSettings & {
            model?: string;
        };
        /**
         * Polling configuration for log analysis.
         */
        polling?: {
            /**
             * Interval between log analysis cycles.
             * @default "3:minutes"
             * @example "1000:ms", "30:seconds", "5:minutes", or 5000
             */
            delay: `${number}:${"minutes" | "seconds" | "ms"}` | number;
            /**
             * Number of recent log lines to analyze in each cycle.
             * @default 10
             * @example tailAmount: 20
             */
            tailAmount?: number;
            /**
             * Timestamp configuration for time-based log filtering.
             * When provided, polling will analyze logs within a rolling time window
             * instead of using tailAmount.
             *
             * @example
             * ```typescript
             * timestampConfig: {
             *   regex: /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)/,
             *   parser: "iso",
             *   timeWindow: "15:minutes" // Analyze logs from last 15 minutes
             * }
             * ```
             */
            timestampConfig?: TimestampConfig & {
                /**
                 * Rolling time window for automatic polling.
                 * Logs within this time window from current time will be analyzed.
                 * @example "15:minutes", "1:hour", "30:seconds"
                 */
                timeWindow: `${number}:${"minutes" | "seconds" | "hours"}` | number;
            };
        };
        /**
         * Event handlers for different situations.
         */
        events: {
            /**
             * Called when an alert is triggered by the AI analysis.
             *
             * @param params - Object containing alert event parameters
             * @param params.options - Current Ailogw configuration
             * @param params.logs - All collected logs
             * @param params.diagnostic - AI analysis results with formatted output
             * @param params.sendSms - Function to send SMS notifications
             *
             * @example
             * ```typescript
             * alert: async ({ options, logs, diagnostic, sendSms }) => {
             *   if (diagnostic.raw.status === "critical") {
             *     await sendSms("+33728926138", diagnostic.formatted);
             *   }
             * }
             * ```
             */
            alert: alertEventCallback;
        };
    };
    interface status {
        polling: "activated" | "paused";
        lastPollingLogIndex: number;
    }
}
export type modelSettings = AilogwTypes.options["modelSettings"];
export type clientOptions = AilogwTypes.options["clientOptions"];
export declare const AILOGW_TWILIO_ACCOUNT_SID = "AILOGW_TWILIO_ACCOUNT_SID";
export declare const AILOGW_TWILIO_AUTH_TOKEN = "AILOGW_TWILIO_AUTH_TOKEN";
export declare const AILOGW_TWILIO_NUMBER_FROM = "AILOGW_TWILIO_NUMBER_FROM";
export declare const ELEVENLABS_API_KEY = "ELEVENLABS_API_KEY";
export declare const BLACKBOX_API_MODEL = "BLACKBOX_API_MODEL";
export declare const BLACKBOX_API_KEY = "BLACKBOX_API_KEY";
export declare const AilogwDefaultOptions: Omit<Required<AilogwTypes.options>, "events" | "name">;
/**
 * AI-powered log monitoring and alerting system using Twilio for SMS notifications.
 *
 * @example
 * ```typescript
 * const ailogwatch = new Ailogw({
 *   name: "vercel",
 *   log: true,
 *   twilio: {
 *     numberFrom: "+17153645914"
 *   },
 *   polling: {
 *     delay: "1000:ms",
 *     tailAmount: 10
 *   },
 *   events: {
 *     async alert(options, logs, diagnostic, sendSms) {
 *       await sendSms("+33625926138", `Alert: ${diagnostic.formatted}`);
 *     }
 *   }
 * });
 *
 * // Feed logs to be analyzed
 * ailogwatch.feedLog("2024-09-16 ERROR Database connection failed");
 * ```
 */
export declare class Ailogw {
    #private;
    /**
     * Creates a new Ailogw instance with the specified configuration.
     *
     * @param options - Configuration options for the log watcher
     * @throws {IncompleteConfig} When required Twilio credentials are missing
     *
     * @example
     * ```typescript
     * const watcher = new Ailogw({
     *   name: "my-app",
     *   twilio: {
     *     accountSid: "ACxxxx",
     *     authToken: "your-token",
     *     numberFrom: "+1234567890"
     *   },
     *   polling: {
     *     delay: "5:minutes",
     *     tailAmount: 20
     *   },
     *   events: {
     *     alert: async (options, logs, diagnostic, sendSms) => {
     *       if (diagnostic.raw.status === "critical") {
     *         await sendSms("+1987654321", diagnostic.formatted);
     *       }
     *     }
     *   }
     * });
     * ```
     */
    constructor(options: AilogwTypes.options);
    private internalLog;
    private log;
    /**
     * Feeds log entries to the watcher for analysis.
     * Logs can be provided as a single string (will be split by newlines) or as an array of strings.
     *
     * @param log - Log entry(ies) to be analyzed. Can be a string or array of strings.
     *
     * @example
     * ```typescript
     * // Single log entry
     * ailogwatch.feedLog("2024-09-16 10:30:25 ERROR Database connection failed");
     *
     * // Multiple log entries as string
     * ailogwatch.feedLog(`2024-09-16 10:30:25 INFO Starting server
     * 2024-09-16 10:30:26 ERROR Connection timeout
     * 2024-09-16 10:30:27 CRITICAL System overload`);
     *
     * // Array of log entries
     * ailogwatch.feedLog([
     *   "2024-09-16 10:30:25 INFO Server started",
     *   "2024-09-16 10:30:26 WARN High memory usage"
     * ]);
     * ```
     */
    feedLog(log: AilogwTypes.maybeArray<AilogwTypes.logType>): void;
    /**
     * Sends an SMS notification using Twilio.
     *
     * @param numberFrom - The recipient's phone number (must include country code)
     * @param customContent - Optional custom message content. If not provided, uses default alert message.
     * @returns Promise that resolves to true if SMS was sent successfully
     *
     * @example
     * ```typescript
     * // Send with custom content
     * await sendSms("+33625926138", "Critical alert: Database down!");
     *
     * // Send with default message
     * await sendSms("+33625926138");
     * ```
     */
    private sendSms;
    /**
     * Creates a formatted diagnostic object from AI analysis results.
     *
     * @param params - Raw diagnostic data from AI analysis
     * @param logs - Complete log array for line number resolution
     * @returns Formatted diagnostic object with both raw and human-readable data
     */
    private createAlertDiagnostic;
    /**
     * Creates a logger that automatically feeds all log entries to the Ailogw instance for AI analysis.
     * The logger wraps the console object and provides the same interface while adding automatic log feeding
     * and optional file writing capabilities.
     *
     * @param options - Optional configuration for file destinations for each log level
     * @returns A logger object with the same interface as console, but with enhanced functionality
     *
     * @example
     * ```typescript
     * // Basic usage - logs will be fed to AI analysis automatically
     * const logger = ailogw.createLogger();
     * logger.info("Server started successfully");
     * logger.error("Database connection failed");
     *
     * // With file destinations - logs will be written to files AND fed to AI analysis
     * const logger = ailogw.createLogger({
     *   destination: {
     *     info: "./logs/info.log",
     *     error: "./logs/errors.log",
     *     warn: "./logs/warnings.log",
     *     debug: "./logs/debug.log"
     *   }
     * });
     *
     * // All log methods automatically feed logs to Ailogw for analysis
     * logger.log("General log message");        // Feeds to Ailogw + optional file
     * logger.info("Information message");       // Feeds to Ailogw + optional file
     * logger.warn("Warning message");           // Feeds to Ailogw + optional file
     * logger.error("Error occurred");           // Feeds to Ailogw + optional file
     * logger.debug("Debug information");        // Feeds to Ailogw + optional file
     *
     * // The logger maintains the same interface as console
     * logger.error("Error:", error.message, { userId: 123 });
     * ```
     *
     * @remarks
     * **Automatic Log Feeding**: Every call to log(), error(), warn(), info(), or debug()
     * automatically feeds the log entry to the Ailogw instance for AI analysis. This means
     * your application logs will be continuously monitored for critical issues.
     *
     * **File Writing**: If destination paths are provided in options, logs will be written
     * to the specified files in addition to console output and AI feeding.
     *
     * **Format**: All log entries are timestamped and formatted as:
     * `YYYY-MM-DDTHH:mm:ss.sssZ LEVEL your message here`
     *
     * **Error Handling**: File writing errors are caught and logged to console.error
     * without interrupting the application flow.
     */
    createLogger(options?: AilogwTypes.CreateLoggerOptions): {
        log: (...args: any[]) => void;
        error: (...args: any[]) => void;
        warn: (...args: any[]) => void;
        info: (...args: any[]) => void;
        debug: (...args: any[]) => void;
        assert(condition?: boolean, ...data: any[]): void;
        assert(condition?: boolean, ...data: any[]): void;
        assert(value: any, message?: string, ...optionalParams: any[]): void;
        clear(): void;
        clear(): void;
        clear(): void;
        count(label?: string): void;
        count(label?: string): void;
        count(label?: string): void;
        countReset(label?: string): void;
        countReset(label?: string): void;
        countReset(label?: string): void;
        dir(item?: any, options?: any): void;
        dir(item?: any, options?: any): void;
        dir(obj: any, options?: import("util").InspectOptions): void;
        dirxml(...data: any[]): void;
        dirxml(...data: any[]): void;
        dirxml(...data: any[]): void;
        group(...data: any[]): void;
        group(...data: any[]): void;
        group(...label: any[]): void;
        groupCollapsed(...data: any[]): void;
        groupCollapsed(...data: any[]): void;
        groupCollapsed(...label: any[]): void;
        groupEnd(): void;
        groupEnd(): void;
        groupEnd(): void;
        table(tabularData?: any, properties?: string[]): void;
        table(tabularData?: any, properties?: string[]): void;
        table(tabularData: any, properties?: readonly string[]): void;
        time(label?: string): void;
        time(label?: string): void;
        time(label?: string): void;
        timeEnd(label?: string): void;
        timeEnd(label?: string): void;
        timeEnd(label?: string): void;
        timeLog(label?: string, ...data: any[]): void;
        timeLog(label?: string, ...data: any[]): void;
        timeLog(label?: string, ...data: any[]): void;
        timeStamp(label?: string): void;
        timeStamp(label?: string): void;
        timeStamp(label?: string): void;
        trace(...data: any[]): void;
        trace(...data: any[]): void;
        trace(message?: any, ...optionalParams: any[]): void;
        write(...data: Array<string | ArrayBufferView | ArrayBuffer>): number;
        Console: console.ConsoleConstructor;
        profile(label?: string): void;
        profileEnd(label?: string): void;
        [Symbol.asyncIterator](): AsyncIterableIterator<string>;
    };
    /**
     * Creates the main polling routine that analyzes logs at regular intervals.
     * Uses AI to analyze new log entries and trigger alerts based on severity.
     * Supports both count-based (tailAmount) and time-based (timestampConfig) filtering.
     *
     * @returns Async function that performs one polling cycle
     */
    private createPollingRoutine;
    /**
     * Manually triggers log analysis for all accumulated logs and optionally flushes them.
     * This allows you to implement your own log rotation mechanism and trigger analysis programmatically.
     * Supports both count-based (tailAmount) and time-based (timeRange) filtering.
     *
     * @param options - Configuration options for the trigger
     * @param options.flush - Whether to clear all logs after analysis (default: false)
     * @param options.tailAmount - Number of recent logs to analyze (ignored if timeRange is provided)
     * @param options.timeRange - Time range filter for logs with timestamp configuration
     * @returns Promise that resolves when analysis is complete
     *
     * @example
     * ```typescript
     * // Analyze all logs and keep them
     * await ailogwatch.triggerAnalysis();
     *
     * // Analyze all logs and flush them (log rotation)
     * await ailogwatch.triggerAnalysis({ flush: true });
     *
     * // Analyze last 50 logs and flush
     * await ailogwatch.triggerAnalysis({ tailAmount: 50, flush: true });
     *
     * // Analyze logs from last hour with ISO timestamp format
     * const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
     * await ailogwatch.triggerAnalysis({
     *   timeRange: {
     *     from: oneHourAgo,
     *     to: new Date(),
     *     timestampConfig: {
     *       regex: /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)/,
     *       parser: "iso"
     *     }
     *   },
     *   flush: true
     * });
     *
     * // Analyze logs with custom timestamp format
     * await ailogwatch.triggerAnalysis({
     *   timeRange: {
     *     from: new Date('2024-01-15T10:00:00'),
     *     to: new Date('2024-01-15T11:00:00'),
     *     timestampConfig: {
     *       regex: /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/,
     *       parser: (ts) => new Date(ts.replace(' ', 'T'))
     *     }
     *   }
     * });
     *
     * // Use with cron job for custom scheduling
     * cron.schedule('0 * * * *', async () => {
     *   await ailogwatch.triggerAnalysis({ flush: true });
     * });
     * ```
     */
    triggerAnalysis(options?: AilogwTypes.TriggerAnalysisOptions): Promise<void>;
    /**
     * Pauses the log polling process.
     * No new logs will be analyzed until polling is reactivated.
     *
     * @example
     * ```typescript
     * ailogwatch.pausePolling();
     * console.log("Log monitoring paused");
     * ```
     */
    pausePolling(): void;
    /**
     * Activates or resumes the log polling process.
     * Starts analyzing logs at the configured interval if not already active.
     *
     * @example
     * ```typescript
     * ailogwatch.activatePolling();
     * console.log("Log monitoring activated");
     * ```
     */
    activatePolling(): void;
    /**
     * Gets the current configuration options for this Ailogw instance.
     *
     * @returns The complete configuration object
     */
    get options(): Required<AilogwTypes.options>;
    /**
     * Converts a delay string or number to milliseconds.
     *
     * @param delay - Delay value as number (ms) or string format "number:unit"
     * @returns Delay in milliseconds
     * @throws {Error} When an invalid time unit is provided
     *
     * @example
     * ```typescript
     * convertDelayToMs(5000) // 5000
     * convertDelayToMs("30:seconds") // 30000
     * convertDelayToMs("5:minutes") // 300000
     * convertDelayToMs("2:hours") // 7200000
     * convertDelayToMs("500:ms") // 500
     * ```
     */
    private convertDelayToMs;
}
