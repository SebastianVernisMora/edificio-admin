// src/realtime/RenderRealtime.ts
import WebSocket from "ws";
import { AilogwRealtimeLogs } from "./AilogwRealtimeLogs.js";
import { RealtimeConnectionFailed } from "../exceptions/index.js";

// node_modules/nanoid/index.js
import { webcrypto as crypto } from "node:crypto";

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}

// src/realtime/RenderRealtime.ts
var RenderRealtime = class extends AilogwRealtimeLogs {
  /** Private WebSocket connection to Render's log streaming API */
  #ws;
  #entryCallback = [];
  /**
   * Creates a new RenderRealtime instance and establishes WebSocket connection.
   * 
   * @param options - Configuration options for connecting to Render's API
   * @param entryCallback - Array of callback functions to handle incoming log entries
   * 
   * @example
   * ```typescript
   * 
   * const renderLogs = new RenderRealtime({
   *   apiKey: "rnd_your_api_key",
   *   ownerId: "usr-12345",
   *   resource: "srv-abcdef"
   * });
   * ```
   */
  constructor(options) {
    super(options);
    this.#ws = this.initWS();
    this.#ws.on("message", (data) => {
      try {
        const logData = JSON.parse(data.toString());
        for (let i = 0; i < this.#entryCallback.length; i++) {
          this.#entryCallback[i]?.callback(logData);
        }
      } catch (error) {
        console.log(`Failed to parse log entry`);
      }
    });
    return this;
  }
  /**
   * Initializes the WebSocket connection to Render's log streaming API.
   * Configures the connection with proper authentication and query parameters.
   * 
   * @returns Configured WebSocket instance
   * @throws {RealtimeConnectionFailed} When WebSocket connection cannot be established
   */
  initWS() {
    const url = new URL("wss://api.render.com/v1/logs/subscribe");
    url.searchParams.set("ownerId", this.options.ownerId);
    url.searchParams.set("direction", "forward");
    url.searchParams.set("resource", this.options.resource);
    url.searchParams.set("limit", "20");
    try {
      const ws = new WebSocket(url.toString(), {
        headers: {
          "authorization": `Bearer ${this.options.apiKey}`
        }
      });
      return ws;
    } catch (e) {
      const _e = e;
      throw new RealtimeConnectionFailed(_e?.message);
    }
  }
  /**
   * Gets the underlying WebSocket connection instance.
   * Useful for accessing WebSocket events or connection state.
   * 
   * @returns The WebSocket instance used for log streaming
   * 
   * @example
   * ```typescript
   * const renderLogs = new RenderRealtime(options);
   * 
   * // Check connection state
   * console.log('WebSocket state:', renderLogs.ws.readyState);
   * 
   * // Listen to connection events
   * renderLogs.ws.on('open', () => console.log('Connected to Render logs'));
   * renderLogs.ws.on('close', () => console.log('Disconnected from Render logs'));
   * ```
   */
  get ws() {
    return this.#ws;
  }
  /**
   * Registers a callback function to handle incoming log entries.
   * Returns a function that can be called to unregister the callback.
   * 
   * @param callback - Function to call when a new log entry is received
   * @returns Function to remove this callback from the list of handlers
   * 
   * @example
   * ```typescript
   * const renderLogs = new RenderRealtime(options);
   * 
   * // Register a callback
   * const unsubscribe = renderLogs.onEntry((logEntry) => {
   *   console.log(`[${logEntry.timestamp}] ${logEntry.message}`);
   *   
   *   // Access log metadata
   *   const level = logEntry.labels.find(l => l.name === 'level')?.value;
   *   if (level === 'error') {
   *     console.error('Error detected:', logEntry.message);
   *   }
   * });
   * 
   * // Later, stop listening
   * unsubscribe();
   * ```
   */
  onEntry(callback) {
    const id = nanoid();
    this.#entryCallback = [...this.#entryCallback, { id, callback }];
    const remove = () => {
      this.#entryCallback = this.#entryCallback.filter((c) => c.id != id);
    };
    return remove;
  }
};
export {
  RenderRealtime
};
